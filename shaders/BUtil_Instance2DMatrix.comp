#version 430

precision OVERWRITE_PRECISION float;

#define WORKGROUP_SIZE WORKGROUP_SIZE_VALUE

layout(local_size_x = RESET_VALUE, local_size_y = 8, local_size_z = 4) in;

// 80 byte
struct Dynamic2D { // binding 4
    vec4 q22_q23_facing_TurnRate;
    vec4 location_Scale;
    vec4 velocity_ScaleRate;
    vec4 timer;
    uvec4 colorBits;
};

layout(std430, binding = 4) restrict buffer BUtilInstanceData_Dynamic2D
{
    Dynamic2D dataDynamic2D[];
};

uniform float amount;
uniform ivec2 instanceRange; // offset, edge

float computeTimerX(in vec4 timer) {
    bool finishSet = timer.x < -2000.0;
    vec2 timerTmp = finishSet ? vec2(-2048.0) : vec2(timer.w, 0.0);
    if (timer.x > 2.0) {
        timerTmp = vec2(timer.y, 2.0);
    } else if (timer.x > 1.0) {
        timerTmp = vec2(timer.z, 1.0);
    }
    float result = timerTmp.x > -500.0 ? fma(timerTmp.x, -amount, timer.x) : timerTmp.y;
    if (timer.x <= 0.0 && timer.x > -2000.0) {
        result = -2048.0;
    } else if (finishSet) result = -5120.0;
    return result;
}

void main() {
	uint globalIndex = (gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y + gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x) * WORKGROUP_SIZE;
	int indexNow = int(gl_LocalInvocationIndex + globalIndex) + instanceRange.x;
	if (indexNow >= instanceRange.y) return;

    Dynamic2D instanceData = dataDynamic2D[indexNow];
    vec4 timer = instanceData.timer;
    if (timer.x < -5000.0) return;

    dataDynamic2D[indexNow].timer.x = computeTimerX(timer);

    float pryFacing = radians(instanceData.q22_q23_facing_TurnRate.z * 0.5);
    float pryCos = cos(pryFacing);
    float prySin = sin(pryFacing);

    float dqz = prySin + prySin;

    dataDynamic2D[indexNow].q22_q23_facing_TurnRate.xyz = vec3(dqz * prySin, dqz * pryCos, mod(fma(instanceData.q22_q23_facing_TurnRate.w, amount, instanceData.q22_q23_facing_TurnRate.z + 360.0), 360.0));
    dataDynamic2D[indexNow].location_Scale = fma(instanceData.velocity_ScaleRate, vec4(amount), instanceData.location_Scale);
}
